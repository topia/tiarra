#!/usr/bin/perl
# -----------------------------------------------------------------------------
# - T i a r r a - :::bootstrap:::
# Copyright (c) 2002-2004 phonohawk. All rights reserved.
# This is free software; you can redistribute it and/or modify it
#   under the same terms as Perl itself.
# -----------------------------------------------------------------------------
# $Id$
# -----------------------------------------------------------------------------
require 5.006;
use strict;
use warnings;
use File::Basename;
use File::Spec;
use Carp;

sub follow_link {
    my ($file, $max_count, $die_on_max) = @_;

    $max_count = 40 unless defined $max_count;
    my ($count, @path) = 0, ();
    push(@path, $file);
    while (-l $file) {
	$file = File::Spec->rel2abs(readlink($file), dirname($file));
	push(@path, $file);
	if (++$count >= $max_count) {
	    if ($die_on_max) {
		carp 'Too many levels of symbolic links';
	    } else {
		last;
	    }
	}
    }
    return @path;
}

BEGIN {
    # untaint
    $0 =~ /^(.+)$/;
    my $self = $1;
    my @add_inc;

    foreach my $path (map dirname($_), reverse follow_link($1)) {
	unshift(@INC,
		map{ File::Spec->catdir($path, $_); } qw(main module));
	unshift(@add_inc, File::Spec->catdir($path, 'bundle'));
    }
    push(@INC, @add_inc);
}

# optional modules
our $threads_is_enabled;
our $ipv6_is_enabled;
our $time_hires_is_enabled;
BEGIN {
    # 5.005 threading model は安定度に疑問がある上あまりサポートされていない
    # ので使わない。
    eval q{
	use threads;
	use threads::shared;
    };
    $threads_is_enabled = ($@ ? 0 : 1);

    eval q{
	use IO::Socket::INET6;
    };
    $ipv6_is_enabled = ($@ ? 0 : 1);

    eval q{
	use Time::HiRes ();
    };
    $time_hires_is_enabled = ($@ ? 0 : 1);

    # 外部から呼べるオプションモジュールの存在チェック。
    sub ipv6_enabled { $ipv6_is_enabled; }
    sub threads_enabled { $threads_is_enabled; }
    sub time_hires_is_enabled { $time_hires_is_enabled; }
}

use Tiarra::Resolver; # early initialization
use Configuration;
use RunLoop;
use ModuleManager;
use ReloadTrigger;
use IO::Handle;
our $terminated = 0;

# version はバージョン番号
our $version = '0';

# based はベースにしている Tiarra のバージョン(パッケージまたは fork 時用)
our $based_version = '';

# short は短いバージョン番号。(CTCP-Version の返答に使われる)
our $short_version = '';


# オリジナル(based_version が未定義)ならば ChangeLog を検索する。
&check_changelog unless $based_version;
# short_version が未定義なら version の値を使う。
$short_version ||= $version;

&install_signal_handlers;

sub check_changelog {
    use IO::File;
    my $seek_offset = -300;
    my $changelog = 'ChangeLog';

    foreach my $file (follow_link($0)) {
	my $dir = dirname($file);
	my $path = File::Spec->catfile($dir, $changelog);
	my $fh = IO::File->new($path, 'r');
	if (defined $fh) {
	    my $revision = undef;
	    my $date = undef;

	    $fh->seek($seek_offset, 2);
	    foreach (<$fh>) {
		if (/\$\QRevision:\E ([\d.]+) \$/) {
		    $revision = $1;
		} elsif (/\$\QDate:\E ([\d\/]+) [\d:]+ \$/) {
		    $date = $1;
		}
	    }
	    $version .= '+cvs-' . $revision if defined $revision;
	    $version .= '(' . $date . ')' if defined $date;

	    my $svnversion;
	    if (-e File::Spec->catfile($dir, '.svnversion')) {
		my $path = File::Spec->catfile($dir, '.svnversion');
		my $fh = IO::File->new($path, 'r');
		$svnversion = <$fh>;
		chomp $svnversion;
	    } elsif (-e File::Spec->catdir($dir, '.svn')) {
		(my $svndir = $dir) =~ s/'/'\''/;
		$svnversion = `svnversion -n '$svndir'`;
	    }
	    $version .= '+svn-' . $svnversion if defined $svnversion && length $svnversion;
	    return;
	}
    }
}

sub help {
    print "\n";
    print "Usage: tiarra [--config=config-file] [options]\n";
    print "\n";
    print "options:\n";
    print "  --help           print this message\n";
    print "  --version        print version infomation\n";
    print "  --dumpversion    print version\n";
    print "  --config=<file>  tiarra configuration file; default is 'tiarra.conf'\n";
    print "  --quiet          don't output any messages to stdout and stderr\n";
    print "  --no-fork        don't move to background when started in quiet mode\n";
    print "  --debug          show debug infomation\n";
    print "  --make-password  prompt you a password to encrypt.\n";
    print "                   *Tiarra doesn't do its normal work with this option*\n";
    print "   -D<symbol>[=<string>]\n";
    print "                   treat as `\@define <symbol> <string>' is in the conf\n";
    print "\n";
    print "If you omit --config=<file> parameter and execute with piped input,\n";
    print "Tiarra will read configuration from stdin(pipe).\n";
    print "  example:\n";
    print "      cat tiarra.conf | sed -e 's/Tiarra/arraiT/g' | ./tiarra --quiet\n";
    print "      gunzip -c tiarra.conf.gz | ./tiarra\n";
    print "\n";
}

sub make_password {
    eval 'use Crypt;';
    print "Tiarra encrypts your raw password to use it for config file.\n";
    print "\n";

    my $password = &find_option('make-password');
    if ($password eq "1") {
	eval 'use Term::ReadLine;';
	my $term = Term::ReadLine->new('tiarra');
	$password = $term->readline("Please enter raw password: ");
	print "\n";
    }
    print Crypt::encrypt($password)." is your encoded password.\n";
    print "Use this for the general/tiarra-password entry.\n";
}

sub find_option {
    my $option = shift;
    foreach my $arg (@ARGV) {
	if ($arg eq "--$option") {
	    return 1;
	} elsif ($arg =~ m/^--$option=(.+)$/) {
	    return $1;
	}
    }
    undef;
}

sub find_options {
    # $opt_regex: オプション名の正規表現。後方参照を一つだけ作る事。
    # 戻り値: ([$1, 値], ...)
    my $opt_regex = shift;
    grep {
	defined;
    } map {
	if (m/^--?$opt_regex=(.+)/) {
	    [$1, $2];
	}
	elsif (m/^--?$opt_regex$/) {
	    [$1, 1];
	}
	else {
	    undef;
	}
    } @ARGV;
}

sub main {
    if (&find_option('help')) {
	&help;
	return 0;
    } elsif (&find_option('version')) {
	print join("\n",get_credit()) . "\n";
	return 0;
    } elsif (&find_option('dumpversion')) {
	print $version . "\n";
	return 0;
    } elsif (&find_option('make-password')) {
	&make_password;
	return 0;
    }

    if (&find_option('debug')) {
	eval q(sub debug_printmsg{printmsg('debug: '.shift)});
	eval q(sub debug_mode{1;});
	$SIG{__WARN__} = sub {
	    ::printmsg(Carp::longmess(@_));
	};
	$SIG{__DIE__} = sub {
	    die @_ if $_[0] =~ /^[Cc]ouldn't connect/;
	    die @_ if $_[0] =~ /^network\/.+:\s*Server replied/;
	    die(Carp::longmess(@_));
	}
    } else {
	eval q(sub debug_printmsg{});
	eval q(sub debug_mode{0;});
    }

    foreach my $pp_define (&find_options(qr/D(.+?)/)) {
	&Configuration::Preprocessor::initial_define(@$pp_define);
    }

    my $conf_file = &find_option('config');
    if (!defined $conf_file) {
	if (!-t STDIN) {
	    $conf_file = undef; # STDINから読む場合はundefを入れておく。
	} elsif (-f 'tiarra.conf') {
	    $conf_file = 'tiarra.conf';
	} else {
	    &help;
	    return 2;
	}
    }

    my $quiet = &find_option('quiet');
    my $no_fork = &find_option('no-fork');

    my $load_config = sub {
	local($|) = 1;

	if (defined $conf_file) {
	    print "Reading configuration from ${conf_file}... ";
	} else {
	    $conf_file = IO::Handle->new->fdopen(fileno(STDIN),'r');
	    print "Reading configuration from stdin... ";
	}

	eval {
	    Configuration->shared_conf->load($conf_file);
	}; if ($@) {
	    die "ERROR: $@\n";
	} else {
	    print "ok\n";
	}
    };

    my $boot = sub  {
	foreach my $line (get_credit()) {
	    print $line,"\n";
	}
	print "\n";
	$load_config->();
	eval {
	    RunLoop->shared_loop->run;
	}; if ($@) {
	    die "Tiarra aborted: $@\n";
	}
    };

    # quietモードならSTDIN, STDOUT, STDERRを閉じる。
    # config の read の関連(STDIN)で boot の寸前に。
    if ($quiet) {
	close STDIN;
	close STDOUT;
	close STDERR;
	#open(STDOUT,"> /dev/null");
	#open(STDERR,"> /dev/null");
    }

    # quietモードであり、且つno-forkオプションが指定されなかったらfork。
    if ($quiet && !$no_fork) {
	my $child_pid = fork;
	if ($child_pid == 0) {
	    # 子プロセス
	    $boot->();
	} elsif (!defined $child_pid) {
	    print "Tiarra: fork() failed.\n";
	}
    } else {
	$boot->();
    }
    return 0;
}

sub printmsg {
    # 文字コードはUTF-8でなければならない。
    my $msg = shift;
    local($|) = 1;
    if (!defined $msg) {
	$msg = '';
    }
    $msg =~ s/\n*$//s;

    # Configurationが読み込まれていない時に文字コード変換するとdie。
    eval {
	local $SIG{__DIE__} = 'IGNORE';
	local $SIG{__WARN__} = 'IGNORE';
	$msg = Unicode::Japanese->new($msg,'utf8')->conv(
	    Configuration->shared_conf->get('general')->stdout_encoding);
    };

    my ($sec,$min,$hour,$day,$mon,$year) = localtime(time);
    $mon++;
    $year += 1900;

    #printf("[%02d/%02d/%04d %02d:%02d:%02d] %s\n",$mon,$day,$year,$hour,$min,$sec,$msg);
    #printf("[%02d/%02d %02d:%02d:%02d] %s\n",$mon,$day,$hour,$min,$sec,$msg);
    printf("[pid:$$ %04d/%02d/%02d %02d:%02d:%02d] %s\n",$year,$mon,$day,$hour,$min,$sec,$msg);
}

sub version {
    $short_version;
}

sub get_credit {
    return (
	(!$based_version ?
	     "- T i a r r a - :::version #${version}:::" :
		 ("- T i a r r a - :::version ${version}:::",
		  "                    based #${based_version}")
	    ),
	    "Copyright (c) 2002-2004 phonohawk. All rights reserved.",
	    "This is free software; you can redistribute it and/or modify it",
	    "  under the same terms as Perl itself.");
}

sub install_signal_handlers {
    local $SIG{__WARN__} = sub {};
    foreach (qw(INT QUIT ABRT TERM)) {
	$SIG{$_} = \&handle_exit;
    }
    $SIG{HUP} = \&handle_reload;
}

sub handle_exit {
    my $signame = shift;
    printmsg('Signal received.');
    &shutdown('Tiarra '.::version.': '.
		  (defined $signame ? "SIG$signame" : 'Signal').
		      ' received; exit');
}

sub handle_reload {
    printmsg('SIGHUP received.');
    ReloadTrigger->reload_conf_if_updated;
    ReloadTrigger->reload_mods_if_updated;
}

sub shutdown {
    my $msg = shift;
    $msg = 'Tiarra '.::version.': shutting down...' if !defined $msg;
    ++$terminated;
    if ($terminated == 1) {
	printmsg("Shutting down... [$msg]");
	RunLoop->shared_loop->terminate($msg);
    } elsif ($terminated == 2) {
	printmsg("Second Terminate Request; Force Exit! [$msg]");
	# force
	ModuleManager->shared_manager->terminate;
	Tiarra::TerminateManager->terminate('main');
	exit;
    } else {
	printmsg("Third Terminate Request; Fatal Exit! [$msg]");
	# fatal
	exit;
    }
}

my $exitval = main;
Tiarra::TerminateManager->terminate('main');
exit $exitval;
