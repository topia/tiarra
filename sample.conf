# -*- tiarra-conf -*-
# -----------------------------------------------------------------------------
# $Id: sample.conf.in 15771 2008-07-13 23:55:21Z drry $
# -----------------------------------------------------------------------------
# tiarra.conf サンプル
#
# Tiarraは起動時に全ての設定をこのファイルから取得します。
# このファイルの文字コードは任意ですが、改行コードはLFもしくはCRLFでなければなりません。
#
# 半角の#で始まる行はコメントとして無視されます。
# 行の途中に#を置いた場合はコメントにはなりません。
#
# 設定行は「設定名 : 値」の形式で指定されます。
# 行の先頭及び末尾、コロンの前後の空白は無視されます。
#
# 特に指定が無い場合、同じ設定を二度以上繰り返した時は最初に定義された設定が有効になります。
#
# ブロックごと省略した場合は、そのブロックの全ての値が省略されたものとみなします。
# ただし省略不可能な設定もありますので御注意下さい。
#
# 「@include foo.conf」という行があると、foo.confがその場所に
#  挿入されたかのように処理します。
#
# {}記号の位置には、それなりの自由度があります。
# 次の例は全て有効です。
# block {
#   foo: bar
# }
#
# block {}
#
# block
# {}
#
# 次の例は全て無効です。
# block {foo: bar}
#
# block
# {foo: bar}
# 
# block {
# foo: bar}
# 
# block
# {foo: bar
# }
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
# generalブロック
#
# tiarra.conf自身の文字コードやユーザー情報などを指定するブロックです。
# -----------------------------------------------------------------------------
general {
  # tiarra.conf自身の文字コード
  # コード名はjis,sjis,euc,utf8,utf16,utf32等。(この値はEncodeまたはUnicode::Japaneseにそのまま渡されます)
  # autoが指定された、または省略された場合は自動判別します。
  conf-encoding: utf8

  # ユーザー情報
  # 省略不能です。
  nick: tiarra
  user: tiarra
  name: Tiarra the "Aeon"

  # どのようなユーザーモードでログインするか。+iwや+iのように指定する。
  # 省略された場合はユーザーモードを特に設定しない。
  #user-mode: +i

  # Tiarraへの接続を許可するホスト名を表わすマスク。
  # 制限をしないのであれば"*"を指定するか省略する。
  client-allowed: *

  # Tiarraが開くポート。ここに指定したポートへクライアントに接続させる。
  # 省略されたらポートを開かない。
  tiarra-port: 6667

  # Tiarraがポートtiarra-portを開く際、IPv6とIPv4のどちらでリスニングを行なうか。
  # 'v4'または'v6'で指定します。デフォルトは'v4'です。
  # IPv6を使うためにはSocket6.pmが利用可能である必要があります。
  #tiarra-ip-version: v4

  # Tiarraがポートtiarra-portを開く際のローカルアドレス。
  # 意味が分からなければ省略して下さい。
  # デフォルトは、IPv4のはINADDR_ANY、IPv6のはin6addr_anyになります。
  #tiarra-ipv4-bind-addr: 0.0.0.0
  #tiarra-ipv6-bind-addr: ::0

  # Tiarraにクライアントが接続する際に要求するパスワードをcryptした文字列。
  # 空の文字列が指定されたり省略された場合はパスワードを要求しない。
  # crypt は ./tiarra --make-password で行えます。
  tiarra-password: xl7cflIcH9AwE

  # 外部プログラムからTiarraをコントロールする為のUNIXドメインソケットの名前。
  # 例えば"foo"を指定した場合、ソケット/tmp/tiarra-control/fooが作られる。
  # 省略された場合はこの機能を無効とする。
  # また、非UNIX環境ではそもそもUNIXドメインソケットが利用可能でないため、
  # そのような場合にもこの機能は無効となる。
  #control-socket-name: test

  # IRCサーバーから送られる文字のコードと、IRCサーバーへ送る文字のコード。
  # それぞれ省略された場合はjis。
  server-in-encoding: utf8
  server-out-encoding: utf8

  # クライアントから受け取る文字のコードと、クライアントへ伝える文字のコード。
  # それぞれ省略された場合はjis。
  client-in-encoding: utf8
  client-out-encoding: utf8

  # Tiarraは標準出力に様々なメッセージを出力するが、その文字コードを指定する。省略時にはutf8となる。
  # ただしtiarra.confのパースが完了するまでは文字コードの変換は行なわれない(つまりこの設定が有効にならない)ことに注意して下さい。
  stdout-encoding: utf8

  # Tiarraはエラーメッセージを標準出力に出力するが、その時に接続しているクライアントがあればクライアントにもNOTICEで送る事が出来る。
  # この値を1にすると、その機能が有効になる。省略するか0を指定するとこの機能は無効になる。
  notice-error-messages: 1

  # Tiarraでチャンネルとユーザーのマスクを指定するときの形式。
  # plum形式とTiarra形式が選択できます。
  #-----------------
  # plum形式: (channelには+や-は使えない。channelは省略すると*とみなす。)
  #   + syntax: user[ channel[ channel[ ...]]]
  #
  #  mask: +*!*@*.example.com #{example}@ircnet +{example3}@ircnet
  #  mask: -*!*@*.example.com #{example2}@2ch,+{example4}@2ch
  #  mask: -*!*@*
  #-----------------
  # Tiarra形式: (channelにも+や-を使える。)
  #   + syntax: channel user
  #
  #  mask: #{example}@ircnet,-#{example2}@2ch    +*!*@*.example.com
  #  mask: ++{example3}@ircnet,-+{example4}@2ch  +*!*@*.example.com # +で始まるチャンネル。
  #  mask: *                                     -*!*@*
  #-----------------
  # となります。この二つはまったく同じマスクを表しています。

  # この値をplumにすると、plum形式、省略するかtiarraを指定すると、Tiarra形式になります。
  chanmask-mode: tiarra

  # サーバーに接続する際、ローカル側のどのアドレスにバインドするか。
  # 意味が分からなければ省略して下さい。
  # デフォルトは、IPv4のはINADDR_ANY、IPv6のはin6addr_anyになります。
  #ipv4-bind-addr: 0.0.0.0
  #ipv6-bind-addr: ::0

  # Tiarra が、 001 や 002 や、 recent log を送信するときなどに使う prefix
  # を指定します。 hostname や FQDN っぽいものを指定すると良いかもしれません。
  # デフォルトは tiarra です。普通変える必要はありません。
  #sysmsg-prefix: tiarra

  sysmsg-prefix-use-masks {
    # sysmsg-prefix を使用する場所を指定する。

    # システムメッセージ(NumericReply など)。デフォルトは * です。
    # ふつうこれを変更する必要はありません。
    system: *

    # 個人宛メッセージ(Notice,Privmsg の中で)。デフォルトはなし。
    #priv: 

    # チャンネル宛メッセージ(Notice,Privmsg の中で)。デフォルトは * です。
    # Ziciz などのクライアントを接続する場合は、
    # -*::log を指定しておくといいかもしれません。
    channel: *
  }

  # Tiarra が nick 変更時の衝突等を処理するモードを指定します。
  # 0: Tiarra が接続時と同様に自動処理します。
  # 1: クライアントにそのまま投げます。
  #    複数のクライアントが nick 重複を処理する場合は非常に危険です。
  #    (設定不足の IRC クライアントが複数つながっている場合も含みます)
  # 2: 対応するエラーメッセージ付きの NOTICE に変換して、
  #    クライアントに投げます。
  # multi-server-mode 時のデフォルトは 0 、 single-server-mode 時のデフォルトは 1 です。
  #nick-fix-mode: 0

  # Tiarra がチャンネルに join する際の挙動を設定します。
  # デフォルト設定で Excess Flood になってしまう場合に設定してください。
  #
  # irc.juggler.jp (2ch@IRC) にて 25 チャンネル以上 join している場合に
  # Excess Flood になってしまった事例があるそうです。

  # JOIN コマンドを送信する間隔 (秒)
  # デフォルトは1秒です。
  join-interval: 1

  # 一つの JOIN コマンドで指定するチャンネルの数
  # デフォルトは5チャンネルです。
  join-channels-per-command: 5

  messages {
    # Tiarra が使用する、いくつかのメッセージを指定する。

    quit {
      # ネットワーク設定が変更され、再接続する場合の切断メッセージ
      netconf-changed-reconnect: Server Configuration changed; reconnect

      # ネットワーク設定が変更され、切断する場合の切断メッセージ
      netconf-changed-disconnect: Server Configuration changed; disconnect
    }
  }
}

# -----------------------------------------------------------------------------
# networksブロック
#
# Tiarraから接続するIRCネットワークの名称です。
# 一つも定義しなかった場合やこのブロックを省略した場合は、
# "main"というネットワークが一つだけ指定されたものと見做します。
# -----------------------------------------------------------------------------
networks {
  # 複数のサーバーへの接続を可能にするかどうか。1(オン)と0(オフ)で指定。
  # これを1にすると、次のnameを複数個定義する事が可能になり、
  # 複数のサーバーに同時に接続出来るようになります。
  # その一方、これを1にしている時は、チャンネル名にネットワーク名が付加される等、
  # IRCの大部分のメッセージがTiarraによる改変を受けます。
  # これを0にしている間は、次のnameを複数個定義する事は出来なくなります。
  # マルチサーバーモードの設定を起動中に変えると、クライアントから見たチャンネル名が
  # 変更になる為、全クライアントが一時的に全てのチャンネルからpartしたように見え、
  # その直後にjoinし直したように見えます。
  # デフォルトでは1です。
  multi-server-mode: 1

  # 接続するIRCネットワークに名前を付けます。この名前は後で使用します。
  # 複数のネットワークに接続したい場合は多重定義して下さい。
  name: ircnet
  name: 2ch
  #name: freenode
  #name: ustream

  # 通常Tiarraではチャンネル名を「#Tiarra@ircnet」のように表現します。
  # これはネットワークircnet内の#Tiarraというチャンネルを表わします。
  # @以降は省略可能ですが、省略された場合のデフォルトのネットワーク名をここで指定します。
  # 省略した場合は最も始めに定義されたnameがデフォルトになります。
  # (そしてnameが一つも無かった場合はmainがデフォルトになります)
  #default: ircnet

  # 上に述べた通り、デフォルトではTiarraはチャンネル名とネットワーク名を@で区切ります。
  # この区切り文字は任意の文字に変更する事が出来ます。省略された場合は@になります。
  #
  # System::PrivTranslator モジュールを利用している場合、 prefix の nick 部分にも
  # 利用されます。そのため、 ! や @ を含む文字列を利用するとクライアントが誤作動する
  # 場合がありますので注意してください。
  channel-network-separator: @

  # 接続先のサーバーから切断された時に、joinしていたそのサーバーのチャンネルをどうするか。
  # 1. "part-and-join"の場合は、切断されるとクライアントにはチャンネルからpartしたように見せ掛け、
  #    再接続に成功すると再びjoinしたように見せ掛ける。最も負荷が高い。(これはplumに似た動作である)
  # 2. "one-message"の場合は、切断されるとクライアントに宛ててTiarraがNOTICEでその旨を報告する。
  #    再接続に成功すると再びNOTICEで報告する。JOINやPARTはしないので、
  #    クライアントからはまだそのチャンネルに残っているかのように見える。
  # 3. "message-for-each"の場合は、切断されるとクライアントに宛ててTiarraが
  #    到達不能になった全てのチャンネルにNOTICEでその旨を報告する。
  #    再接続に成功すると再びNOTICEで報告する。JOINやPARTはしない。
  # 省略時のデフォルトはpart-and-joinです。
  action-when-disconnected: message-for-each

  # NICKを変更する度に、変更したサーバーでの新しいNICKをNOTICEで常に通知するかどうか。
  # 1なら必ず通知し、0なら変更後のnickがローカルnick(クライアントが見る事の出来るnick)と違っている場合のみ通知する。
  # デフォルトは0です。
  always-notify-new-nick: 0

  fixed-channels {
    # Tiarra がクライアント接続時にチャンネル情報を送る順番を指定する。
    # マッチしなかったチャンネルについては最後にまとめて
    # (順番がごちゃごちゃになって)送られてきます。
    channel: #てすとちゃんねる@ircnet
    channel: #てすと@localserver
    channel: *@localserver
    channel: *@localserver:*.jp
  }
}

# -----------------------------------------------------------------------------
# 各ネットワークの設定
#
# networksブロックで定義した全てのネットワークについて、
# そのアドレス、ポート、(必要なら)パスワードを定義します。
# -----------------------------------------------------------------------------
ircnet {
  # サーバーのホストとポートを指定。複数行可。(host/port が指定されていない場合は)省略不可。
  # 同じサーバの複数のポート指定は順番に試すので、大量に書かない方がよい。
  server: irc.ircnet.ne.jp 6667
  server: irc.media.kyoto-u.ac.jp 6662 6663
  server: irc.huie.hokudai.ac.jp 6667

  # サーバーのホストとポート。(server が指定されていない場合は)省略不可。
  # server を指定した場合は server が優先されます。
  #host: irc.media.kyoto-u.ac.jp
  #port: 6663

  # general/userで設定したユーザ名を使わずに、各ネットワークで独自のユーザ名を使用する事も可能。
  # 省略されたら当然、general/userで設定したものが使われる。
  #user: hoge

  # general/nameで設定した本名(建前上)を使わずに、各ネットワークで独自の本名を使用可能。
  #name: hoge

  # このサーバーの要求するパスワード。省略可能。
  #password: hoge

  # general/setver-in/out-encodingで設定した文字のコードを使わずに、
  # 各ネットワークで独自の文字コードを使用する事も可能。
  # 省略されたら当然、generalで設定したものが使われる。
  in-encoding: jis
  out-encoding: jis

  # general/(ipv4|ipv6)bind-addrで設定したローカルアドレスを使わずに、
  # 各ネットワークで独自のbind_addrを使用する事も可能。
  # 省略されたらgeneralで設定したものが使われる。
  #ipv4-bind-addr: 0.0.0.0
  #ipv6-bind-addr: ::0
}

2ch {
  server: irc.2ch.net 6667
  server: irc2.2ch.net 6667
  server: irc.juggler.jp 6667

  in-encoding: jis
  out-encoding: jis
}

# -----------------------------------------------------------------------------
# 必須の設定は以上です。以下はモジュール(プラグイン)の設定です。
# -----------------------------------------------------------------------------

# +または-で始まる行はモジュール設定行と見做されます。
# +で記述されたモジュールが使用され、-で記述されたモジュールは使用されません。
# +や-の後の空白は幾つあっても無視されます。

#   メッセージが各モジュールを通過する順番は、このconfファイルで記述された
# 順番の通りになります。ログを取るモジュールなどはconfでも後の方に
# 記述した方が良いということになります。

#   モジュール名はperlのそれと同じようにディレクトリ区切り文字を「::」としたパスで表現されます。
# 例えばモジュールChannel::Auto::Operの実体はファイルmodule/Channel/Auto/Oper.pm
# でなければならず、そのpackage宣言もChannel::Auto::Operでなければなりません。
#   Tiarraモジュールの名称は、perl標準モジュール群やmain/下の.pmファイルと重複しないように
# 気を付けて下さい。Tiarraはモジュールが本当にModuleのサブクラスかどうかをチェックするので
# 例えばIO::Socket::INETといったモジュールを置いても誤動作はしませんが、
# そのようなモジュールはロード時にエラーを出して使用中止になります。

# 一つのモジュールを複数回定義して、何度も同じモジュールをメッセージが通過するようには出来ません。

# 幾つかのモジュールはパラメータとしてチャンネル名を必要とします。
# ここで指定するチャンネル名は、ネットワーク名も含めた文字列でなければなりません。
# 「#チャンネル」では駄目で「#チャンネル@ネットワーク」などとする必要があります。

# マスクの書式:
# ['+' / '-'] ( <マスク文字列> / "re:" 正規表現 )
# これはカンマで幾つでも継ぐ事が出来ます。"\,"でカンマそのものを表します。
# 先頭が+なら、それに続く部分にマッチするものが選ばれ、-なら除外されます。省略されたら+と見做されます。
# マスク文字列とは"*"で0文字以上の任意の文字列を、"?"で1文字の任意の文字列を表す文字列です。
# 例:
# tiarra*  これはtiarraで始まる文字列を表す。
# +*!*tiarra@*.jp,-re:\d  これは*!*tiarra@*.jpにマッチして、かつ文字列中に数字を含まないものを表す。

# このファイルには重要と思われるいくつかのモジュールしかありません。
# そのほかのモジュールについては、 all.conf から設定をコピーしてきてください。

- Auto::Oper {
  # 特定の文字列を発言した人を+oする。

  # Auto::Aliasを有効にしていれば、エイリアス置換を行ないます。

  # +oを要求する文字列(マスク)を指定します。
  request: なると寄越せ

  # チャンネルオペレータ権限を要求した人と要求されたチャンネルが
  # ここで指定したマスクに一致しなかった場合は
  # denyで指定した文字列を発言し、+oをやめます。
  # 省略された場合は誰にも+oしません。
  # 書式は「チャンネル 発言者」です。
  # マッチングのアルゴリズムは次の通りです。
  # 1. チャンネル名にマッチするmask定義を全て集める
  # 2. 集まった定義の発言者マスクを、定義された順にカンマで結合する
  # 3. そのようにして生成されたマスクで発言者のマッチングを行ない、結果を+o可能性とする。
  # 例1:
  # mask: *@2ch* *!*@*
  # mask: #*@ircnet* *!*@*.hoge.jp
  # この例ではネットワーク 2ch の全てのチャンネルで誰にでも +o し、
  # ネットワーク ircnet の # で始まる全てのチャンネルでホスト名 *.hoge.jp の人に+oします。
  # #*@ircnetだと「#hoge@ircnet:*.jp」などにマッチしなくなります。
  # 例2:
  # mask: #hoge@ircnet -*!*@*,+*!*@*.hoge.jp
  # mask: *            +*!*@*
  # 基本的に全てのチャンネルで誰にでも +o するが、例外的に#hoge@ircnetでは
  # ホスト名 *.hoge.jp の人にしか +o しない。
  # この順序を上下逆にすると、全てのチャンネルで全ての人を +o する事になります。
  # 何故なら最初の* +*!*@*が全ての人にマッチするからです。
  mask: * *!*@*

  # +oを要求した人を実際に+oする時、ここで指定した発言をしてから+oします。
  # #(name|nick)のようなエイリアス置換を行います。
  # エイリアス以外でも、#(nick.now)を相手のnickに、#(channel)を
  # そのチャンネル名にそれぞれ置換します。
  message: 了解

  # +oを要求されたが+oすべき相手ではなかった場合の発言。
  # 省略されたら何も喋りません。
  deny: 断わる

  # +oを要求されたが相手は既にチャンネルオペレータ権限を持っていた場合の発言。
  # 省略されたらdenyに設定されたものを使います。
  oper: 既に@を持っている

  # +oを要求されたが自分はチャンネルオペレータ権限を持っていなかった場合の発言。
  # 省略されたらdenyに設定されたものを使います。
  not-oper: @が無い

  # チャンネルに対してでなく自分に対して+oの要求を行なった場合の発言。
  # 省略されたらdenyに設定されたものを使います。
  private: チャンネルで要求せよ

  # チャンネルの外から+oを要求された場合の発言。+nチャンネルでは起こりません。
  # 省略されたらdenyに設定されたものを使います。
  out: チャンネルに入っていない
}

- CTCP::ClientInfo {
  # CTCP CLIENTINFOに応答する。

  # CTCP::Versionのintervalと同じ。
  interval: 3
}

- CTCP::DCC::RewriteAddress {
  # クライアントが送信した CTCP DCC のアドレスを変換する。

  # CTCP DCC に指定されているアドレスを、 Tiarra で取得したものに
  # 書き換えます。(EXPERIMENTAL)
  #
  # IPv4 のみサポートしています。
  #
  # このモジュールは一旦 CTCP DCC メッセージを破棄するので、
  # 別のクライアントには送信されません。

  # 変換する DCC タイプ。 [デフォルト値: CHAT SEND]
  type: CHAT SEND

  # 変換用アドレスの取得方法を選択する。デフォルト値はありません。
  # 以下の取得方法(server-socket client-socket dns http)から
  # 必要なもの(複数可)を指定してください。
  resolver: client-socket server-socket dns http


  # 取得方法と設定
  # なにも設定がないときはブロック自体を省略することもできます。

  server-socket {
    # サーバソケットのローカルアドレスを取ります。
    # client <-> tiarra[this address] <-> server
  }

  client-socket {
    # クライアントソケットのリモートアドレスを取ります。
    # client [this address]<-> Tiarra <-> server
  }

  dns {
    # DNS を引いて決定します。IPアドレスの指定も可能です。
    host: example.com
  }

  http {
    # 現状では単純な GET しかサポートしていません。

    # アクセス先 URL
    url: http://checkip.dyndns.org/

    # IP アドレス取得用 regex
    regex: Current IP Address: (\d+\.\d+\.\d+\.\d+)
  }

  # リゾルバの選び方
  #
  #  * Tiarra を動作させているサーバとインターネットの間にルータ等があり、
  #    グローバルアドレスがない場合
  #      *-socket は役に立ちません。 http を利用してください。
  #      適当な DDNS を持っていればdns も良いでしょう。
  #
  #  * Tiarra がレンタルサーバなどLAN上にないサーバで動作している場合
  #      server-socket, http は役に立ちません。
  #      client-socket がお勧めです。
  #
  #  * Tiarra がLAN上にあり、グローバルアドレスのついているホストで
  #    動作している場合
  #      client-socket は役に立ちません。
  #      server-socket がお勧めです。
}

- CTCP::Ping {
  # CTCP PINGに応答する。

  # CTCP::Versionのintervalと同じ。
  interval: 3
}

- CTCP::Time {
  # CTCP TIMEに応答する。

  # CTCP::Versionのintervalと同じ。
  interval: 3
}

- CTCP::UserInfo {
  # CTCP USERINFOに応答する。

  # CTCP::Versionのintervalと同じ。
  interval: 3

  # USERINFOとして返すメッセージ。
  message: テスト
}

+ CTCP::Version {
  # CTCP VERSIONに応答する。

  # 連続したCTCPリクエストに対する応答の間隔。単位は秒。
  # 例えば3秒に設定した場合、一度応答してから3秒間は
  # CTCPに一切応答しなくなる。デフォルトは3。
  #
  # なお、CTCP受信時刻の記録は、全てのCTCPモジュールで共有される。
  # 例えばCTCP VERSIONを送った直後にCTCP CLIENTINFOを送ったとしても、
  # CTCP::ClientInfoのintervalで設定された時間を過ぎていなければ
  # 後者は応答しない。
  interval: 3
}

- Channel::Join::Connect {
  # サーバーに初めて接続した時、指定したチャンネルに入るモジュール。

  # 書式: <チャンネル1>[,<チャンネル2>,...] [<チャンネル1のキー>,...]
  #     コンマの直後のスペースは無視されます。
  #
  # 例:
  #   「#aaaaa@ircnet」に「aaaaa」というキーで入る。
  #channel: #aaaaa@ircnet aaaaa
  #
  #   「#aaaaa@ircnet」、「#bbbbb@ircnet:*.jp」、「#ccccc@ircnet」、「#ddddd@ircnet」の4つのチャンネルに入る。
  #channel: #aaaaa@ircnet,#bbbbb@ircnet:*.jp, #ccccc@ircnet
  #channel: #ddddd@ircnet

  # join 送出の間隔(秒)
  # この設定は obsolete です。 general/join-interval を利用してください。
  # 設定されていた場合は general/join-interval に優先されます。
  #interval: 1
}

- Channel::Join::Invite {
  # 招待されたらそのチャンネルに入る。

  # 許可するユーザ/チャンネルのマスク。
  mask: * *!*@*
  # plum: *!*@*

  # 招待されたチャンネルに流すメッセージのフォーマット。
  #message: こんばんわ〜。
}

- Channel::Join::Kicked {
  # 特定のチャンネルからkickされた時に、自動で入りなおす。

  # 対象となるチャンネル名のマスク
  channel: *
}

- Channel::Mode::Get {
  # チャンネルにJOINした時、そのチャンネルのモードを取得します。

  # Channel::Mode::Set等が正しく動くためには
  # チャンネルのモードをTiarraが把握しておく必要があります。
  # 自動的にモードを取得するクライアントであれば必要ありませんが、
  # そうでなければこのモジュールを使うべきです。

  # 設定項目は無し。
}

- Channel::Mode::Oper::Grant {
  # 特定のチャンネルに特定の人間がjoinした時に、自分がチャンネルオペレータ権限を持っていれば+oする。

  # splitからの復帰などで+o対象の人が一度に大量に入って来ても+oは少しずつ実行します。
  # Excess Floodにはならない筈ですが、本格的な防衛BOTに使える程の物ではありません。

  # 対象の人間がjoinしてから実際に+oするまで何秒待つか。
  # 省略されたら待ちません。
  # 5-10 のように指定されると、その値の中でランダムに待ちます。
  wait: 2-5

  # チャンネルと人間のマスクを定義。Auto::Operと同様。
  #mask: * example!~example@*.example.ne.jp
}

- Channel::Mode::Set {
  # チャンネルを作成した時に自動的にモードを設定するモジュール。

  # 書式は<チャンネル名にマッチするマスク> <設定するモード>[,<設定するモード>,...]です。
  # #IRC談話室@ircnetなら+t+nを、それ以外なら+nを設定する例。
  #channel: #IRC談話室@ircnet +t
  #channel: *                +n
  # LimeChat 標準設定を模倣する設定例。
  #channel: * +sn
}

- Channel::Rejoin {
  # チャンネルオペレータ権限を無くしたとき、一人ならjoinし直す。

  # +チャンネルや+aされているチャンネル以外でチャンネルオペレータ権限を持たずに
  # 一人きりになった時、そのチャンネルの@を復活させるために自動的にjoinし直すモジュール。
  # トピック、モード、banリスト等のあらゆるチャンネル属性をも保存します。

  # +b,+I,+eリストの復旧を行なうかどうか。
  # あまりに長いリストを取得するとMax Send-Q Exceedで落とされるかも知れません。
  save-lists: 1
}

- Client::Cache {
  # データをキャッシュしてサーバに問い合わせないようにする

  # キャッシュを使用しても、使われるのは接続後最初の一度だけです。
  # 二度目からは通常通りにサーバに問い合わせます。
  # また、クライアントオプションの no-cache を指定すれば動きません。

  # mode キャッシュを使用するか
  use-mode-cache: 1

  # who キャッシュを使用するか
  use-who-cache: 1
}

+ Client::Conservative {
  # サーバが送信するような IRC メッセージを作成するようにする

  # サーバが実際に送信しているようなメッセージにあわせるようにします。
  # 多くのクライアントの設計ミスを回避でき(ると思われ)ます。
}

- Client::Cotton {
  # Cotton の行うおかしな動作のいくつかを無視する

  # 該当クライアントのオプション client-type に cotton や unknown と指定するか、
  # Client::GetVersion を利用してクライアントのバージョンを取得するように
  # してください。

  # part shield (rejoin 時に自動で行われる part の無視)を使用するか
  use-part-shield: 1
}

+ Client::GetVersion {
  # クライアントに CTCP Version を発行してバージョン情報を得る

  # オプションはいまのところありません。
  # (開発者向け情報: 取得した情報は remark の client-version に設定され、
  #                  Client::Guess から使用されます。)
}

- Log::Channel {
  # チャンネルやprivのログを取るモジュール。

  # Log系のモジュールでは、以下のように日付や時刻の置換が行なわれる。
  # %% : %
  # %Y : 年(4桁)
  # %m : 月(2桁)
  # %d : 日(2桁)
  # %H : 時間(2桁)
  # %M : 分(2桁)
  # %S : 秒(2桁)

  # ログを保存するディレクトリ。Tiarraが起動した位置からの相対パス。~指定は使えない。
  directory: log

  # ログファイルの文字コード。省略されたらjis。
  charset: utf8

  # 各行のヘッダのフォーマット。省略されたら'%H:%M'。
  header: %H:%M:%S

  # ファイル名のフォーマット。省略されたら'%Y.%m.%d.txt'
  filename: %Y.%m.%d.txt

  # ログファイルのモード(8進数)。省略されたら600
  mode: 600

  # ログディレクトリのモード(8進数)。省略されたら700
  dir-mode: 700

  # ログを取るコマンドを表すマスク。省略されたら記録出来るだけのコマンドを記録する。
  command: privmsg,join,part,kick,invite,mode,nick,quit,kill,topic,notice

  # PRIVMSGとNOTICEを記録する際に、自分の発言と他人の発言でフォーマットを変えるかどうか。1/0。デフォルトで1。
  distinguish-myself: 1

  # 各ログファイルを開きっぱなしにするかどうか。
  # このオプションは多くの場合、ディスクアクセスを抑えて効率良くログを保存しますが
  # ログを記録すべき全てのファイルを開いたままにするので、50や100のチャンネルを
  # 別々のファイルにログを取るような場合には使うべきではありません。
  # 万一 fd があふれた場合、クライアントから(またはサーバへ)接続できない・
  # 新たなモジュールをロードできない・ログが全然できないなどの症状が起こる可能性が
  # あります。limit の詳細については OS 等のドキュメントを参照してください。
  #keep-file-open: 1

  # keep-file-open 時に各行ごとに flush するかどうか。
  # open/close の負荷は気になるが、ログは失いたくない人向け。
  # keep-file-open が有効でないなら無視され(1になり)ます。
  #always-flush: 0

  # keep-file-openを有効にした場合、発言の度にログファイルに追記するのではなく
  # 一定の分量が溜まってから書き込まれる。そのため、ファイルを開いても
  # 最近の発言はまだ書き込まれていない可能性がある。
  # syncを設定すると、即座にログをディスクに書き込むためのコマンドが追加される。
  # 省略された場合はコマンドを追加しない。
  sync: sync

  # 各チャンネルの設定。チャンネル名の部分はマスクである。
  # 個人宛てに送られたPRIVMSGやNOTICEはチャンネル名"priv"として検索される。
  # 記述された順序で検索されるので、全てのチャンネルにマッチする"*"などは最後に書かなければならない。
  # 指定されたディレクトリが存在しなかったら、Log::Channelはそれを勝手に作る。
  # フォーマットは次の通り。
  # channel: <ディレクトリ名> (<チャンネル名> / 'priv')
  # 例:
  # filename: %Y.%m.%d.txt
  # channel: IRCDanwasitu #IRC談話室@ircnet
  # channel: others *
  # この例では、#IRC談話室@ircnetのログはIRCDanwasitu/%Y.%m.%d.txtに、
  # それ以外(privも含む)のログはothers/%Y.%m.%d.txtに保存される。
  # #(channel) はチャンネル名に展開される。
  # (古いバージョンだと展開されずにそのままディレクトリ名になってしまいます。)
  # IRCのチャンネル名は大文字小文字が区別されず、サーバからは各送信者が指定した通りの
  # チャンネル名が送られてきます。そのため、大文字小文字が区別されるファイルシステムでは
  # 同じチャンネルが別々のディレクトリに作られることになります。
  # この問題を回避するため、チャンネル名を小文字に統一した #(lc_channel) が利用できます。
  channel: priv priv
  channel: #(lc_channel) *
  #channel: others *

  # ファイル名のエンコーディング.
  # 指定可能な値は, utf8, sjis, euc, jis, ascii.
  # ascii は実際には utf8 と同等で8bit部分が全てquoted-printableされる.
  # デフォルトはWindowsではsjis, それ以外では utf8.
  #filename-encoding: utf8
}

- Log::Recent {
  # クライアントを接続した時に、保存しておいた最近のメッセージを送る。

  # クライアントオプションの no-recent-logs が指定されていれば送信しません。

  # 各行のヘッダのフォーマット。省略されたら'%H:%M'。
  header: %H:%M:%S

  # ログをチャンネル毎に何行まで保存するか。省略されたら10。
  line: 15

  # PRIVMSGとNOTICEを記録する際に、自分の発言と他人の発言でフォーマットを変えるかどうか。1/0。デフォルトで1。
  distinguish-myself: 1

  # どのメッセージを保存するか。省略されたら保存可能な全てのメッセージを保存する。
  command: privmsg,notice,topic,join,part,quit,kill
}

+ Network::Freenode {
  # Freenode サポート

  # 現状では ChanServ の検出以外の機能はありません。
  # drop による状況の変化についてもサポートしていません。

  # Channel::Rejoin では、このモジュールによってチャンネルが
  # ChanServ の管理下にあると検出した時には Rejoin 動作を
  # 行わなくなります。

  # 設定はありません。
  # また、 freenode 以外のネットワークでこのモジュールが
  # 有効になっていても不都合はないはずです。
}

+ System::Error {
  # サーバーからのERRORメッセージをNOTICEに埋め込む

  # これをoffにするとクライアントにERRORメッセージがそのまま送られます。
  # クライアントとの間ではERRORメッセージは主に切断警告に使われており、
  # そのまま流してしまうとクライアントが混乱する可能性があります。
  #   設定項目はありません。

  # このモジュールを回避してERRORメッセージをクライアントに送りたい場合は、
  # remarkのsend-error-as-is-to-clientを指定してください。
}

- System::NotifyIcon::Win32 {
  # タスクトレイにアイコンを表示する。

  # タスクトレイにアイコンを表示します。
  # クリックすると表示非表示を切り替えることができ、右クリックすると
  # Reload と Exit ができるコンテキストメニューを表示します。
  # 多少反応が鈍いかもしれませんがちょっと待てば出てくると思います。

  # Win32::GUI を必要とします。
  # コンテキストメニューは表示している間処理をブロックしています。

  # Win32 イベントループを処理する最大間隔を指定します。
  #interval: 2

  # 通知領域に表示するアイコンを指定します。
  # Win32::GUI の制限でちゃんとしたアイコンファイルしか指定できません。
  iconfile: guiperl.ico

  # モジュールが読み込まれたときにコンソールウィンドウを隠すかどうかを
  # 指定します。
  hide-console-on-load: 1
}

+ System::Pong {
  # サーバーからのPINGメッセージに対し、自動的にPONGを返す。

  # これをoffにするとクライアントが自らPINGに応答せざるを得なくなりますが、
  # クライアントからのPONGメッセージはデフォルトのサーバーへ送られるので
  # デフォルト以外のサーバーからはPing Timeoutで落とされるなど
  # 全く良い事がありません。
  #   設定項目はありません。
}

+ System::PrivTranslator {
  # クライアントからの個人的なprivが相手に届かなくなる現象を回避する。

  # このモジュールは個人宛てのprivmsgの送信者のnickにネットワーク名を付加します。
  # また、最後に声をかけられてから5分以内の nick 変更をクライアントに伝えます。
  # 設定項目はありませんが、 networks/channel-network-separator を ! や @ 以外に
  # 変更することをおすすめします。
}

+ System::Reload {
  # confファイルやモジュールの更新をリロードするコマンドを追加する。

  # リロードを実行するコマンド名。省略されるとコマンドを追加しません。
  # 例えば"load"を設定すると、"/load"と発言しようとした時にリロードを実行します。
  # この時コマンドはTiarraが握り潰すので、IRCプロトコル上で定義された
  # コマンド名を設定すべきではありません。
  command: load

  # command と同じですが、サーバにもブロードキャストします。
  #broadcast-command: load-all

  # confファイルをリロードしたときに通知します。
  # モジュールの設定が変更されていた場合は、ここでの設定にかかわらず、
  # モジュールごとに表示されます。1または省略された場合は通知します。
  conf-reloaded-notify: 1
}

- User::Away::Client {
  # クライアントが一つも接続されていない時にAWAYを設定します。

  # どのようなAWAYメッセージを設定するか。省略された場合はAWAYを設定しません。
  #away: 居ない。
}

- User::Away::Nick {
  # ニックネーム変更に応じて AWAY を設定します。

  # ニックネームを変更したときに、そのニックネームに対応するAWAYが
  # 設定されていれば、そのAWAYを設定します。そうでなければAWAYを取り消します。

  # 書式: <nickのマスク> <設定するAWAYメッセージ>
  #
  # nickをhoge_zzzに変更すると、「寝ている」というAWAYを設定する。
  # hoge_workまたはhoge_zzzに変更した場合は、「仕事中」というAWAYを設定する。
  # それ以外のnickに変更した場合はAWAYを取り消す。
  # 後者は正規表現を利用して「away: re:hoge_(work|zzz) 仕事中」としても良い。
  #away: hoge_zzz           寝ている
  #away: hoge_work,hoge_zzz 仕事中
}

- User::Nick::Detached {
  # クライアントが接続されていない時に、特定のnickに変更します。

  # クライアントが接続されていない時のnick。
  # このnickが既に使われていたら、適当に変更が加えられて使用されます。
  # クライアントが再び接続されると、切断前のローカルnickに戻ります。
  detached: PHO_d
}

